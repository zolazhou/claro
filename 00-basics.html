<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Basic Resolution</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.17</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="00-basics.html"><div class="inner"><span>Basic Resolution</span></div></a></li><li class="depth-1 "><a href="01-projection.html"><div class="inner"><span>Projections</span></div></a></li><li class="depth-1 "><a href="02-advanced-projection.html"><div class="inner"><span>Advanced Projections</span></div></a></li><li class="depth-1 "><a href="03-engine.html"><div class="inner"><span>Engine</span></div></a></li><li class="depth-1 "><a href="04-testing-and-debugging.html"><div class="inner"><span>Testing &amp; Debugging</span></div></a></li><li class="depth-1 "><a href="99-notes.html"><div class="inner"><span>Implementation Notes</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3 branch"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-3"><a href="claro.engine.selector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>selector</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>middleware</span></div></div></li><li class="depth-3 branch"><a href="claro.middleware.deferred.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deferred</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.observe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>observe</span></div></a></li><li class="depth-3"><a href="claro.middleware.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#basic-resolution" name="basic-resolution"></a>Basic Resolution</h1>
<p>claro is a library that allows you to streamline your data access, providing powerful optimisations and abstractions along the way.</p>
<pre><code class="clojure">(require '[claro.data :as data]
         '[claro.engine :as engine]
         '[manifold.deferred :as d])
</code></pre>
<h3><a href="#resolvables" name="resolvables"></a>Resolvables</h3>
<p>We define our data access as records implementing the <code>Resolvable</code> protocol.</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (fetch-person! (:db env) id))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> You won’t be able to use <code>extend-type</code>/<code>extend-protocol</code> with <code>Resolvable</code> – claro won’t pick those values up since (for performance reasons) it checks for the <em>interface</em>, not the protocol.</p>
</blockquote>
<p>Now, we can create an instance of our resolvable and retrieve the respective value:</p>
<pre><code class="clojure">(engine/run!! (-&gt;Person 1))
;; =&gt; {:id 1, :name "Sherlock Holmes"}
</code></pre>
<p>But Resolvables don’t have to be top-level values, they can be anywhere within a nested structure:</p>
<pre><code class="clojure">(engine/run!! {:sherlock (-&gt;Person 1), :watson (-&gt;Person 2)})
;; =&gt; {:sherlock {:id 1, :name "Sherlock Holmes"}
;;     :watson   {:id 2, :name "John Watson"}}
</code></pre>
<p>And this way you can even write resolvables that produce other resolvables:</p>
<pre><code class="clojure">(defrecord FriendsOf [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (-&gt;&gt; (fetch-friend-ids! (:db env) id)
           (map -&gt;Person)))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> <code>d/future</code> creates a Manifold future but you can use any deferred value, e.g. Clojure futures or the result of <code>ExecutorService.submit()</code>.</p>
</blockquote>
<h3><a href="#pure-vs-impure-logic" name="pure-vs-impure-logic"></a>Pure vs. Impure Logic</h3>
<p>To increase <a href="04-testing-and-debugging.html">testability</a> it generally makes sense to separate your impure logic (I/O) from your pure one (transformation of I/O results). To facilitate this, claro lets resolvables implement the <a href="claro.data.html#var-Transform">Transform</a> protocol which will be automatically be used to postprocess resolution results.</p>
<p>The previous example can thus be rewritten as:</p>
<pre><code class="clojure">(defrecord FriendsOf [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (fetch-friend-ids! (:db env) id)))

  data/Transform
  (transform [_ friend-ids]
    (map -&gt;Person friend-ids)))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> <code>transform</code> expects a single result as input, even if your <code>Resolvable</code> implements the batching mechanisms outlined in the next section.</p>
</blockquote>
<p>While this split-up is completely optional, it is highly recommended. See the topic <a href="04-testing-and-debugging.html">Testing &amp; Debugging</a> on how to best leverage it.</p>
<p>Note that there are two helper macros for common transformation types, namely <a href="claro.data.html#var-extend-transform">extend-transform</a> and <a href="claro.data.html#var-extend-list-transform">extend-list-transform</a>.</p>
<h3><a href="#batching" name="batching"></a>Batching</h3>
<p>With our above records, resolving a <code>FriendsOf</code> record for someone that has a hundred friends will produce a hundred <code>Person</code> queries. This is usually both unwanted and unnecessary since data access can be batched.</p>
<p>You can tell claro that there is such a batchwise resolution logic by additionally implementing the <code>BatchedResolvable</code> protocol:</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  data/BatchedResolvable
  (resolve-batch! [_ env people]
    (d/future
      (fetch-people! (:db env) (map :id people)))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> Don’t forget to also implement <code>Resolvable</code> – this is after all what claro takes to identify values of interest.</p>
</blockquote>
<p><code>resolve-batch!</code> gets a seq of all values to resolve (including the current one) as its third parameter. It has to return results in an order matching the input, e.g. the result seqs first element is the resolved value for the first resolvable, and so on.</p>
<h3><a href="#mutations" name="mutations"></a>Mutations</h3>
<p>Nothing prevents you from performing side-effects in <code>resolve!</code> or <code>resolve-batch!</code> but letting them run wild can produce unexpected results. This is why you should always mark them with the <code>Mutation</code> protocol:</p>
<pre><code class="clojure">(defrecord IncrementBy [n]
  data/Mutation
  data/Resolvable
  (resolve! [_ {:keys [counter]}]
    (swap! counter + n)))
</code></pre>
<p>claro imposes some healthy restrictions on mutations:</p>
<ul>
  <li>They can only be used at the top-level, i.e. they cannot be returned from  <code>resolve!</code> or <code>resolve-batch!</code>.</li>
  <li>There can only be one mutation per call to <code>engine/run!!</code> – the caller is  responsible for execution order.</li>
  <li>If mutations and normal resolvables are mixed, the mutation will be run before  any other values.</li>
</ul>
<p>They are, however, normal resolvables when it comes to their return value.</p></div></div></div></body></html>